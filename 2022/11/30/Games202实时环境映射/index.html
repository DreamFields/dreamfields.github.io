

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#435266">
  <meta name="description" content="">
  <meta name="author" content="木夕">
  <meta name="keywords" content="">
  <meta name="description" content="前言  《Real-Time Rendering 3rd 提炼总结》第五章纹理贴图及相关技术  作为纹理管线的第一步，投影函数的功能就是将空间中的三维点转化为纹理坐标，也就是获取表面的位置并将其投影到参数空间中。 在常规情况下，投影函数通常在美术建模阶段使用，并将投影结果存储于顶点数据中。也就是说，在软件开发过程中，我们一般不会去用投影函数去计算得到投影结果，而是直接使用在美术建模过程中，已经存">
<meta property="og:type" content="article">
<meta property="og:title" content="Games202-04实时环境映射">
<meta property="og:url" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/index.html">
<meta property="og:site_name" content="Dream Fields">
<meta property="og:description" content="前言  《Real-Time Rendering 3rd 提炼总结》第五章纹理贴图及相关技术  作为纹理管线的第一步，投影函数的功能就是将空间中的三维点转化为纹理坐标，也就是获取表面的位置并将其投影到参数空间中。 在常规情况下，投影函数通常在美术建模阶段使用，并将投影结果存储于顶点数据中。也就是说，在软件开发过程中，我们一般不会去用投影函数去计算得到投影结果，而是直接使用在美术建模过程中，已经存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%201.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%202.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%203.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%204.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%205.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%206.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%207.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%208.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%209.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2010.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2011.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2012.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2013.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2014.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2015.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2016.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2017.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2018.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2019.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2020.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2021.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2022.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2023.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2024.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2025.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2026.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2027.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2028.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2029.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2030.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2031.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2032.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2033.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2034.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2035.png">
<meta property="og:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2036.png">
<meta property="article:published_time" content="2022-11-30T13:51:46.000Z">
<meta property="article:modified_time" content="2023-05-13T10:26:07.074Z">
<meta property="article:author" content="木夕">
<meta property="article:tag" content="CG">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled.png">
  
  <title>Games202-04实时环境映射 - Dream Fields</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"♥","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"6YjqtdnCXWEze6YQenySAIQJ-gzGzoHsz","app_key":"86QJklER4kphwsPLL8tnbFs4","server_url":"https://6yjqtdnc.lc-cn-n1-shared.com","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Dream Fields</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/blog.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Games202-04实时环境映射">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-11-30 21:51" pubdate>
        2022年11月30日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.4k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      23 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Games202-04实时环境映射</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<blockquote>
<p>《Real-Time Rendering 3rd 提炼总结》第五章纹理贴图及相关技术</p>
</blockquote>
<p>作为纹理管线的第一步，投影函数的功能就是将空间中的三维点转化为纹理坐标，也就是获取表面的位置并将其投影到参数空间中。</p>
<p>在常规情况下，投影函数通常在美术建模阶段使用，并将投影结果存储于顶点数据中。也就是说，在软件开发过程中，我们一般不会去用投影函数去计算得到投影结果，而是直接使用在美术建模过程中，已经存储在模型顶点数据中的投影结果。但有一些特殊情况，例如：</p>
<p>1、OpenGL的glTexGen函数提供了一些不同的投影函数，包括球形函数和平面函数。利用空闲时间可以让图形加速器来执行投影过程，而这样做的优点是不需要将纹理坐标送往图形加速器，从而可以节省带宽。</p>
<p>2、更一般的情况， 可以在顶点或者像素着色器中使用投影函数，这可以实现各种效果，包括一些动画和一些渲染方法（比如如环境贴图，environment mapping，有自身特定的投影函数，可以针对每个顶点或者每个像素进行计算）。</p>
<p>通常在建模中使用的投影函数有球形、圆柱、以及平面投影，也可以选其他一些输入作为投影函数。</p>
<h1 id="环境光照"><a class="markdownIt-Anchor" href="#环境光照"></a> 环境光照</h1>
<p><strong>环境贴图</strong>：在场景中任意一点往四周看去可看到的光照,将其记录在一张图上这就是环境光照,或者也可以叫做<strong>IBL(image-based lighing)</strong>.这里我们认为看到的光照来自于无限远处,这也就是为什么用环境光照去渲染物体时会产生一种漂浮在空中的感觉,因为光照来自于无限远处.</p>
<p><strong>存储：用spherical map和cube map</strong>来存储环境光照。</p>
<p>下面详述在实时渲染领域求环境光照的过程。</p>
<h1 id="情况一已知环境光照不考虑遮挡求任何物体任何一点shading值"><a class="markdownIt-Anchor" href="#情况一已知环境光照不考虑遮挡求任何物体任何一点shading值"></a> 情况一：已知环境光照，不考虑遮挡，求任何物体任何一点shading值</h1>
<h2 id="问题引入"><a class="markdownIt-Anchor" href="#问题引入"></a> 问题引入</h2>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled.png" srcset="/img/loading.gif" lazyload alt></p>
<p>通用解法：对上面的渲染方程使用蒙特卡洛积分，缺点是需要采集大量样本，时间消耗多</p>
<p><strong>解决思路：避免采样</strong></p>
<h2 id="基本思路"><a class="markdownIt-Anchor" href="#基本思路"></a> 基本思路</h2>
<p>根据以上渲染方程，不考虑遮挡（Visibility项），只需要将BRDF与Lighting项相乘再进行半球积分即可。</p>
<h3 id="brdf又分为两种情况"><a class="markdownIt-Anchor" href="#brdf又分为两种情况"></a> <strong>BRDF又分为两种情况:</strong></h3>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%201.png" srcset="/img/loading.gif" lazyload alt></p>
<ol>
<li><strong>BRDF为glossy时</strong>,覆盖在球面上的范围很小,也就是small support(积分域).</li>
<li><strong>BRDF为diffuse时</strong>,它会覆盖整个半球的区域,但是是smooth的,也就是值的变化不大,就算加上cos也是相对平滑的.</li>
</ol>
<p>这两种情况均满足下面的近似公式的相等条件</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%202.png" srcset="/img/loading.gif" lazyload alt></p>
<h3 id="the-spilt-sum-1st-stage不采样计算lighting"><a class="markdownIt-Anchor" href="#the-spilt-sum-1st-stage不采样计算lighting"></a> <strong>The spilt sum: 1st stage——不采样计算Lighting</strong></h3>
<p>将渲染方程中的lighting项拆出，同样对于Visibility项也可以这样拆出：</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%203.png" srcset="/img/loading.gif" lazyload alt></p>
<p>上图的橙色区域含义：将brdf范围内的lighting积分起来并进行normalize，<strong>等价于将IBL这张图给模糊</strong>了，<strong>等价于在任何一点上取周围一片范围求出范围内的平均值并将平均值写回这个点上</strong></p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%204.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Pre-filtering：在rendering之前</strong>把滤波环境光生成，提前将不同卷积核的滤波核的环境光生成一系列模糊过的图（和mipmap相似），当我们需要时进行查询即可,其他尺寸的图则可以经过这些已生成的通过三线性插值得到。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%205.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%206.png" srcset="/img/loading.gif" lazyload alt></p>
<p>接着在BRDF部分求shading point值，需要以一定立体角的范围内进行采样再加权平均从而求出shading point的值，而有了<strong>Pre-filtering后的环境光之后，就可以等价于从镜面反射方向望去在pre-filtering的图上的一点进行查询，因此省去了采样的操作。</strong></p>
<h3 id="the-spilt-sum-2nd-stage不采样计算brdf"><a class="markdownIt-Anchor" href="#the-spilt-sum-2nd-stage不采样计算brdf"></a> <strong>The spilt sum: 2nd stage——不采样计算BRDF</strong></h3>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%207.png" srcset="/img/loading.gif" lazyload alt></p>
<p>回到渲染方程的另一个部分——BRDF，如果使用预计算的方法，需要将参数的所有可能性均考虑进去,但是比较多，包括roughness、color等。考虑所有参数的话我们需要打印出一张五维或者更高的表格,这样会拥有爆炸的存储量,因此我们需要想办法降低维度,也就是减少参数量从而实现预计算.</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%208.png" srcset="/img/loading.gif" lazyload alt></p>
<p>上图回顾了微表面模型的BRDF，由于此时暂时不考虑阴影，此处需要关注的是Fresnel term和distribution of normals。</p>
<p><strong>处理过程</strong></p>
<ul>
<li>
<p>Fresnel term：利用Schlick的近似方法可以近似成一个参数为<strong>基础反射率R0</strong>和<strong>入射角度</strong>的指数函数</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%209.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
<li>
<p>distribution of normals：是一个一维的分布，其中有两个变量，一个变量粗糙程度定义是diffuse还是gloosy，另一个 是half vector和法线的夹角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">\theta_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，可以近似成入射角度相关的数</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2010.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
<li>
<p>至此我们有了三个变量:基础反射率r0,roughness α 和角度 θ ,三维的预计算仍然是一个存储量爆炸的结果,因此我们还要想办法减少参数量.(PS:在这里我们认为反射角,入射角,half vector可以用一个角 θ 代替).于是将Schlick近似代入后半部分积分，基础反射R0被拆出积分式，需要预计算的两个量就只有roughness α 和角度 θ</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2011.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
<li>
<p>可以将预计算结果绘制成一张纹理，在使用时进行查询即可。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2012.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
</ul>
<p>另外补充一点工业界对于积分的做法：将积分写成求和，这也是在UE引擎里面所使用的环境光技术</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2013.png" srcset="/img/loading.gif" lazyload alt></p>
<h1 id="情况二已知环境光照考虑遮挡求任何物体任何一点shading值带阴影"><a class="markdownIt-Anchor" href="#情况二已知环境光照考虑遮挡求任何物体任何一点shading值带阴影"></a> 情况二：已知环境光照，考虑遮挡，求任何物体任何一点shading值（带阴影）</h1>
<h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2>
<p>严格意义上来讲,这是不可能完成的事,因为以目前的技术来说是很难实现的,要从两个考虑角度来说:</p>
<ol>
<li><strong>many light问题</strong>：我们把环境光理解为很多个小的光源,这种情况下去生成阴影的话,需要在每个小光源下生成shadow map,因此会生成线性于光源数量的shadow map,这是十分高昂的代价。</li>
<li><strong>sampling问题</strong>：在任何一个Shading point上已知来自正半球方向的光照去解rendering equation,最简单的方法是采样空间中各方向上的不同光照,可以做重要性采样,虽然做了重要性采样但仍需要大量的样本,因为最困难的是visibility term。由于Shading point不同方向上的遮挡是不相同的,我们可以对环境光照进行重要性采样,但一个Shading point周围的visibility项是未知的,因此我们只能盲目的去采样，无法提取出visibility项。因为如果是glossy brdf，他是一个高频的，Lighting项的积分域是整个半球,因此并不满足smooth或small support，因此无法利用近似公式来提取出visibility项.</li>
</ol>
<ul>
<li>在工业界：通常以环境光中最亮的那个作为主要光源,也就是太阳,只生成太阳为光源的shadow。</li>
<li>学术界
<ul>
<li>Imperfect shadow maps：做的是全局光照部分产生的shadow</li>
<li>Light cuts：解决的是离线渲染中的many lights的问题,核心思想是把反射物当成小光源,把所有的小光源做一下归类并近似出照射的结果</li>
<li>RTRT (might be the ultimate solution)：Real Time Ray Tracing,可能是最终解决方案</li>
<li><strong>Precomputed radiance transfer：PRT，可以十分准确的得到来自环境光中的阴影</strong></li>
</ul>
</li>
</ul>
<p>接下来就使用<strong>PRT</strong>的方法来求环境光照下考虑阴影的shading值，<strong>其主要思想是</strong>：</p>
<ul>
<li>PRT 通过一种预计算方法，该方法在离线渲染的 Path Tracing 工具链中预计算 lighting 以及 light transport 并将它们用球谐函数拟合后储存，这样就将时间开销转移到了离线中。</li>
<li>最后通过使用这些预计算好的数据，我们可以轻松达到实时渲染严苛的时间要求，同时渲染结果可以呈现出全局光照的效果。</li>
</ul>
<h2 id="数学基础"><a class="markdownIt-Anchor" href="#数学基础"></a> 数学基础</h2>
<p><strong>基函数</strong>：把一个函数可以描绘成其他函数的线性组合,如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>可以描绘成一系列的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Bi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span></span></span></span>函数乘以各自对应的系数最终再相加在一起,这一系列的函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Bi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span></span></span></span>就是基函数.</p>
<p><strong><strong>Spherical Harmonics(球谐函数)：SH是一系列基函数,系列中的每个函数都是2维函数,并且每个二维函数都是定义在球面上的。下图是SH的可视化</strong>：</strong></p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2014.png" srcset="/img/loading.gif" lazyload alt></p>
<p>与一维的傅里叶一样,SH也存在不同频率的函数，但不同频率的函数个数也不同,频率越高所含有的基函数越多。</p>
<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>表示的是阶数，通常第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>阶有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个基函数，前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>阶有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个基函数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>表示的是在某一个频率下基函数的序号，分别从从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>。每个基函数都有一个比较复杂的数学表示，对应一个legendre多项式，我们不用去了解legendre多项式,我们只需要知道基函数长这样,可以被某些数学公式来定义不同方向的值是多少就可以了.</p>
<p><strong>投影</strong>：由于一个函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> 可以由一系列基函数和系数的线性组合表示，那么怎么确定基函数前面的系数，这就需要通过投影操作：</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2015.png" srcset="/img/loading.gif" lazyload alt></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>通过对应的基函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>进行投影操作,从而求出各基函数对应的系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Ci</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">i</span></span></span></span>。</p>
<p>如何理解投影：在空间中想描述一个向量，可以xyz三个坐标来表达，把xyz轴当做三个基函数，把向量投影到xyz轴上，得到三个系数就是三个坐标。</p>
<p><strong>重建</strong>：知道基函数对应的系数，就能用系数和基函数恢复原来的函数。</p>
<p>由于基函数的阶可以是无限个的，越高的阶可恢复的细节就越好,但一方面是因为更多的系数会带来更大的存储压力、计算压力，而<strong>一般描述变化比较平滑的环境漫反射部分，用3阶SH就足够。</strong></p>
<h2 id="prt过程"><a class="markdownIt-Anchor" href="#prt过程"></a> PRT过程</h2>
<p>在实时渲染中,考虑阴影的情况下我们把rendering equation写成由三部分组成的积分:</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2016.png" srcset="/img/loading.gif" lazyload alt></p>
<p>如果不进行预计算，就是遍历每个像素去解这个方程，假设环境光是6∗64∗64的map，对于每个shading point来说，计算shading需要计算6∗64∗64次。</p>
<p>而利用SH就可以将一些内容预计算，以节省时间开销，基本思想是：将rendering equation分为两部分,lighting 和 light transport。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2017.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li><strong>lighting</strong>：假设在渲染时场景中只有lighting项会发生变化(旋转,更换光照等),由于lighting是一个球面函数,因此可以用基函数来表示,在预计算阶段计算出lighting.</li>
<li><strong>light transport(visibility和brdf)</strong>：相当于对任一shading point来说,light transport项固定的,可以认为是shading point自己的性质,light transport总体来说还是一个球面函数,因此也可以写成基函数形式,是可以预计算出的.</li>
</ul>
<h3 id="diffuse-prt计算"><a class="markdownIt-Anchor" href="#diffuse-prt计算"></a> Diffuse PRT计算</h3>
<p><strong>第一种理解方式</strong>：</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2018.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>
<p>BRDF几乎为常数，可以提取到积分之外</p>
</li>
<li>
<p>Lighting项写为基函数形式（黄色部分），每个基函数前的系数（Lighting投影到某个基函数）为常数，可以提取到积分之外，这里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 是入射方向</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2019.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
<li>
<p>积分中只剩下基函数和visibility项，相乘之后得到的也是常数，相当于visibility项投影到基函数得到常数系数，最终的效果是把visibility项分解成了多个常数项（组成向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2020.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
<li>
<p>最终计算任何一个shading point，只需要计算光照系数和visibility系数分别相乘，相当于两个向量点乘</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2021.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
</ul>
<p><strong>第二种理解方式</strong>：</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2022.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>
<p>将Lighting与light transport独立开来，分别投影到各自的SH基函数上，也就是说两者使用了两套SH，分开投影。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2023.png" srcset="/img/loading.gif" lazyload alt></p>
</li>
<li>
<p>结果得到了<strong>Lighting与light transport各自的基函数系数*各自的基函数相乘的积分， 只有p和q下标相等的基函数相乘为1，其余为0（SH的正交性），与第一种理解方式是一样的结果。</strong></p>
</li>
</ul>
<p><strong>PRT方法的主要限制</strong></p>
<ul>
<li><strong>光源</strong>：预计算的光源我们把它投影到SH上，如果旋转，可以通过SH的旋转不变性解决，但是不能计算随机动态场景的全局光照</li>
<li><strong>场景</strong>：light transport做了预计算,因此visibility相当于常量,因此场景不能动,因此只能对静止物体进行计算.</li>
</ul>
<h3 id="glossy-prt计算"><a class="markdownIt-Anchor" href="#glossy-prt计算"></a> Glossy PRT计算</h3>
<p>Diffuse和glossy的区别：</p>
<ul>
<li><strong>diffuse的brdf是一个常数，<strong>而</strong>glossy的brdf是一个4维的brdf</strong>(2维的输入方向，2维的输出方向，而<strong>SH中所表示的i或者o表示二维的输入方向或者二维的输出方向，只是在形式上只些了一个字母作为函数的变量</strong>)。</li>
<li>直观一点来说,glossy物体有一个很重要的性质,它是和视点有关的，不同的视角得到的shading result也是不一样的。diffuse的物体不管视角如何旋转改变,看到的Shading point的result是不会改变的,因为整个Diffuse shading和视角是无关的。</li>
</ul>
<p>因此，在计算Glossy材质的PRT时，需要考虑视点方向，也就是光线的出射方向。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2024.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Lighting项投影到SH上，得到一系列常数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>剩余的BRDF、visibility项继续投影到SH，会得到关于出射方向的函数，每个出射方向都对应了一系列常数（每个出射方向的投影结果相当于Diffuse PRT得到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）</li>
<li><strong>最终的BRDF、visibility项的结果会是一个矩阵（所有的入射方向到所有的出射方向的预计算结果，矩阵维度取决于SH的阶数，而不是有多少入射方向和出射方向）</strong></li>
</ul>
<p>效果：</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2025.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>Glossy下使用PRT产生的问题</strong>：</p>
<ul>
<li>存储巨大，四阶的SH得到16个基函数，每个点需要16阶向量与16*16的矩阵相乘。</li>
<li>Diffuse情况下一般三阶SH就足够，但是当Glossy非常高频时，也就是接近镜面反射的情况的时候， PRT就没有那么好用，我们虽然可以采用更高阶的SH来描述高频信息，但是使用SH甚至远不如直接采样方便。</li>
</ul>
<h1 id="情况三考虑多次bounce"><a class="markdownIt-Anchor" href="#情况三考虑多次bounce"></a> 情况三：考虑多次bounce</h1>
<p>我们可以用一系列的表达式来描述不同光线传播的路径都是一种什么类。区分材质区分为三种：</p>
<ol>
<li>Diffuse</li>
<li>Specular镜面反射</li>
<li>Glossy 介于两者之间</li>
</ol>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2026.png" srcset="/img/loading.gif" lazyload alt></p>
<p>传播路径的区分：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">LE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>：Light直接到眼Eye</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>G</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">LGE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>：Light打到Glossy物体然后到眼Eye</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>G</mi><mi>G</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">LGGE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">G</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>：多bounce一次,就是Light先打到壶嘴,在bounce到壶身,最后到眼。(L-&gt;Glossy-&gt;Glossy-&gt;Eye)</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>G</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mi>E</mi></mrow><annotation encoding="application/x-tex">L(D|G)^*E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span><span class="mord mathdefault">G</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>：Light从光源出发,打到一个物体,可能是Diffuse也可能是Glossy,*表示bounce次数,最后到达眼Eye</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>S</mi><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>G</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mi>E</mi></mrow><annotation encoding="application/x-tex">LS(D|G)^*E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span><span class="mord mathdefault">G</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>：打到Specular面上，然后聚焦到Diffuse物体上,最后被眼睛看到，也就是caustics材质</li>
</ol>
<p>结论：</p>
<ul>
<li><strong>所有路径开始都是L最后都是E，因此我们在运用PRT时候，把L和E中间所有的东西都看作是Light transport。</strong></li>
<li>拆分为light和light transport之后,不管中间boucne几次,我们只需要预计算出Light transport就行，不论多么复杂的bounce,我们只需要计算出light transport就能得出最后的shading result。</li>
</ul>
<p><strong>计算方式</strong>：</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2027.png" srcset="/img/loading.gif" lazyload alt></p>
<p>理解方式1：把light transport（图上红色下划线部分）投影到SH基函数（做了一个<strong>Product Integral）</strong></p>
<p>理解方式2：把light transport的预计算看作是基函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B_i(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>照亮了场景的渲染过程。换句话说，把基函数看为lighting项，那么light transport就是rendering equation，我们把light transport投影到basis上，相当于用basis这个Lighting照亮物体，每个basis得到一个渲染图，最后我们进行重建从而得出最后的shading值。而解这部分的过程依旧和解渲染方程一样。</p>
<p>渲染效果：</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2028.png" srcset="/img/loading.gif" lazyload alt></p>
<h1 id="prt方法总结"><a class="markdownIt-Anchor" href="#prt方法总结"></a> PRT方法总结</h1>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2029.png" srcset="/img/loading.gif" lazyload alt></p>
<p>Sloan在02年提出的这个方法（即PRT），使用球谐函数估计光照和光线传输，将光照变成光照系数，将光线传输变成系数或者矩阵的形式，通过预计算和存储光线传输将渲染问题变为每个vertex/shading point：点乘（diffuse表面）、向量矩阵乘法（glossy表面）。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2030.png" srcset="/img/loading.gif" lazyload alt></p>
<p>由于球谐函数的性质，该方法比较适合使用于低频的情况（可用于高频但不合适,如图即使使用了26*26阶的sh仍然得不到比较好的效果）；当改变场景或者材质时需要重新预计算light transport，此外预计算的数据比较大。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2031.png" srcset="/img/loading.gif" lazyload alt></p>
<p>基于Sloan依旧有许多后续的研究…</p>
<h1 id="其它基函数"><a class="markdownIt-Anchor" href="#其它基函数"></a> 其它基函数</h1>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2032.png" srcset="/img/loading.gif" lazyload alt></p>
<p>此外，基函数除了可以使用球谐函数外，还有很多选择，比如Wavelet、Zonal Harmonics、Spherical Gaussian、Piecewise Constant等。</p>
<h2 id="wavelet小波函数"><a class="markdownIt-Anchor" href="#wavelet小波函数"></a> Wavelet小波函数</h2>
<p>小波变换的过程就是投影过程，相比于球谐函数对低频内容友好（球谐函数使用少量的基去表示），小波变换可以全频率表示，但是只有很少的系数是非零的.</p>
<p>由于小波是平面上的函数，为了防止变换后在球面上出现缝隙，所以采用了<strong>Cubemap</strong>来作为环境光而不是Sphereical map。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2033.png" srcset="/img/loading.gif" lazyload alt></p>
<p>从图中可以看到,小波变化是把每张图的高频信息留在这张图的左下,右上和右下三部分,而把剩余的低频信息放在左上角,左上角的信息可以继续进行小波变换,我们会发现高频的东西很少,对于绝大部分来说是0,不断地进行小波变换可以得到一个很不错的既保留了低频又保留了高频的压缩.</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2034.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2035.png" srcset="/img/loading.gif" lazyload alt></p>
<p>但是小波也有自己的缺陷：不支持旋转（使用球谐函数进行表示时，由于球谐函数具有<strong>simple rotation</strong>的性质，所以支持光源的旋转）。</p>
<p><img src="/2022/11/30/Games202%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84/Untitled%2036.png" srcset="/img/loading.gif" lazyload alt></p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=5">Lecture5 Real-time Environment Mapping_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=6">Lecture6 Real-time Environment Mapping_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY/?p=7">Lecture7 Real-time GLobal Illumination (in 3D)_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/371112302">Games202 高质量实时渲染笔记lecture 05 Real-Time Environment Mapping - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/373697912">Games202 高质量实时渲染笔记lecture 06 Real-Time Environment Mapping 02 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377104538">GAMES202 高质量实时渲染笔记Lecture07：Real-Time Global Illumination (In 3D) - 知乎 (zhihu.com)</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CG/">CG</a>
                    
                      <a class="hover-with-bg" href="/categories/CG/GAMES202/">GAMES202</a>
                    
                      <a class="hover-with-bg" href="/categories/Theory/">Theory</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CG/">CG</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/15/Games202%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Games202-05实时全局光照</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/20/Games202%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/">
                        <span class="hidden-mobile">Games202-03实时阴影</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"6YjqtdnCXWEze6YQenySAIQJ-gzGzoHsz","appKey":"86QJklER4kphwsPLL8tnbFs4","path":"window.location.pathname","placeholder":"留下你的足迹","visitor":"true // 阅读量统计","avatar":"monsterid","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>